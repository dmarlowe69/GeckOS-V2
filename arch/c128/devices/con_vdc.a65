
/****************************************************************************
   
    OS/A65 Version 2.2
    Multitasking Operating System for 6502 Computers

    Copyright (C) 1989-2024 Andre Fachat 

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

****************************************************************************/

#define	CHECK_C128

#define	MAX_SCREEN	3		/* hard maximum number of screens */

#define	MAX_ASCREEN	#3		/* soft maximum number of screens */

#define	SWITCHKEY	61

#define	SET_MMU

#define	BELLIRQ	

#define	TRIGBELL	

#define	MAXSPAL		#80

#define	MAXZEIL		#25

#define	KEY_START	20	/* when does key repetition start */

#define	SCR_SPACE	32

#define	SCR2ASC

#define	ASC2SCR

#define	FGCOL		2

#include "chips/vdc.i65"

        .data 
hivid	.byt 0		; current high byte of char text addr

col	.byt 0		; current column in window
row	.byt 0		; current row in window

wx	.byt 0		; top left window column (absolute)
wy	.byt 0		; top left window row (absolute)
ww	.byt 0		; window width (rel to wx)
wh	.byt 0		; window height (rel. to wy)

iz	.byt 0		; line number of start of input
is	.byt 0		; column of start of input

cptr	.word 0		; current memory pointer

tmp	.byt 0		; temp counter
	.text

	;-------------------------------------------------
	; VDC memory map (16k)
	;
	; $2000		- 8k character "ROM"
	; $1800		- 2k attributes (vdc1)
	; $1000		- 2k character text (vdc1)
	; $0800		- 2k attributes (vdc0)
	; $0000		- 2k character text (vdc0)
	;
	;-------------------------------------------------

VDC	=$d600
VDCI	=VDC		; index register
VDCD	=VDC+1		; data register

; according to https://c-128.freeforums.net/thread/67/correct-write-vdc-registers
; it is possible to read/write most registers in a "fast" way, but if 
; you want to run the mass data transfer, you certainly need to 
; a) check for the busy bit 7 in VDCI on reading regs 18/19, 30-32, and
; b) write hi/lo sequence in reg pairs 18/19 and 32/33, and obey
;    the busy bit for the high byte, and
; c) obey the busy bit when writing to reg 31.
; 
; according to the C128 ROM here i
; https://github.com/mist64/cbmsrc/blob/5c5138ff128d289ccd98d260f700af52c4a75521/EDITOR_C128/ed2.src
; writing multiple bytes to vdc memory requires a "kludge" to make sure
; all bytes are written (as opposed to copy, which seems not to need this)

vdcfrd	.(
	stx VDCI
	lda VDCD
	rts
	.)

vdcfwr	.(
	stx VDCI
	sta VDCD
	rts
	.)

vdcwr	.(
	stx VDCI
l	bit VDCI
	bpl l
	sta VDCD
	rts
	.)

vdcrd	.(
	stx VDCI
l	bit VDCI
	bpl l
	lda VDCD
	rts
	.)

	;-------------------------------------------------

console_init .(
	jsr inivid
	jsr inicrsr
	jsr inikbd
	rts
	.)

inivid	.(
	; init the VDC registers
	; TODO
	; set the background colour
	; TODO
	jsr inivscr
inc $d020
	jsr toff
	rts
	.)

	; set the virtual screen that is to be displayed
	; TODO: switch cursor off on old, and on on new scr
setact	.(
	; assume always a valid screen number (0 or 1 here)
	asl
	asl
	asl
	asl
	ldx #VDC_MEM_STRT_H
	jsr vdcfwr
	ora #$08
	ldx #VDC_ATT_STRT_H
	jmp vdcfwr
	.)

/**************************************************************************
 * actual screen handling
 */

	; set the structures such that all output goes to curdev
setscr	.(
	; TODO
	rts
	.)


sendline .(
	; TODO
	rts
	.)

	; initialize a virtual screen - clear it, cursor to home
inivscr	.(
	lda actdev
	
	and #1
	asl
	asl
	asl
	asl
	sta hivid

	jsr towcl
	
	lda #TC_FF
	jsr printchar

	jsr setlin
	
	clc
	rts
	.)

setlin	.(
	lda row
	sta iz
	lda col
	sta is
	rts
	.)



/**************************************************************************
 * helper routines
 */

setchr	.(
	ldx #VDC_UPDATE_H
	lda cptr+1
	jsr vdcwr
	inx
	lda cptr
	jmp vdcwr
	.)

setcol	.(
	ldx #VDC_UPDATE_H
	lda cptr+1
	ora #$08
	jsr vdcwr
	inx
	lda cptr
	jmp vdcwr
	.)
	
setptr	.(
	ldx col
	ldy row
	jsr calcaddr
	sta cptr
	sty cptr+1

	lda actscr
	cmp actdev
	bne done

	ldx #VDC_CRSR_POS_H
	lda cptr+1
	jsr vdcwr
	inx
	lda cptr
	jmp vdcwr

done	rts
	.)

	; take col/row in current window in X/Y respectively
	; return memory address of col/row in vdc in A/Y
calcaddr .(
	tya
	clc 
	adc wy
	tay
	txa
	clc
	adc wx		; should not overflow
	adc rowl,y
	pha
	lda #0
	adc rowh,y
	adc hivid
	tay
	pla
	rts
	.)

/**************************************************************************
 * char output
 */

printchar .(
	ldx actdev
	ldy ctrlst,x
	bne extra
	
	tay
	bmi x1
	cmp #32
	bcs outc
	jmp xout
x1	cmp #128+32
	bcs outc
	jmp xcode
outc	
	pha
	; check if prev. print left us in the the col behind the window 
	ldx col
	cpx ww
	bcc outok
	; if so, then wrap over to next line, col 0
	ldx #0
	stx col
	jsr nextrow
outok
	jsr setptr
	jsr setchr
	pla
	ldx #VDC_UPDATA
	jsr vdcwr
	jsr setcol
	lda #FGCOL
	jsr vdcwr
	; fall-through
nextcol	
	inc col
	ldx col
	cpx ww
	beq colok
	bcc colok
	dec col
colok	rts

&nextrow .(
	ldx row
	inx
	cpx wh
	bcs nok
stx $c000
	stx row
	rts

nok	ldx #0
	stx row
	.)
	; fall-through
scrollup .(
	; TODO
	rts
	.)

	.)

/**************************************************************************
 * control char output
 */

xout      .(    ;2
          cmp #TC_CR
          bne x1
          lda #0
          sta col
          rts
x1        cmp #TC_LF
          bne x3a
          jmp nextrow
x3a       
          cmp #TC_FF
          bne x3
	  jmp toff
x3        
          ;cmp #TC_BS
          ;bne x4
x4	  rts
          .)    ;2

xcode	rts
extra	rts

&toff	.(
	; set to write (not copy)
	ldx #VDC_VSCRL
	jsr vdcfrd
	and #%01111111
	jsr vdcwr

	; first row/col in win
	ldy #0
	sty tmp
lloop
	ldx #0
	jsr calcaddr
	; start of line address in a/y

	; write high, then low
	pha
	tya
	ldx #VDC_UPDATE_H
	jsr vdcwr
	inx
	pla
	jsr vdcwr

	lda #SCR_SPACE
	ldx #VDC_UPDATA
	jsr vdcwr

	lda ww
	sec
	sbc #1
	jsr clr_kludge
	
	inc tmp
	ldy tmp
	cpy wh
	bcc lloop
	rts	

clr_kludge_1
	lda #1
clr_kludge
	ldx #VDC_UPLEN
	jsr vdcwr
	; TODO kludge - not needed in VICE right now
	rts
	.)

	; clear window definition
towcl	.(
	lda #0
	sta wx
	sta wy
	lda MAXSPAL
	sta ww
	lda MAXZEIL
	sta wh
	rts
	.)
	; fall-through
tohome	.(
	lda #0
	sta col
	sta row
	jmp setlin
	.)

/**************************************************************************
 * Cursor handling
 */

          .(
        .data
;crsrfl  .byt 0
;crsrcnt .byt 0
        .text

&inicrsr
;	lda #0
;	sta crsrfl
;	sta crsrcnt
	rts

&crsroff .(                    ; disable cursor
;          bit crsrfl
;          bpl ret               ; not enabled
;
;          bit crsrfl
;          bvc clr               ; not inversed
;          ldy spalte
;          lda (vzei),y
;          eor #$80
;          sta (vzei),y
;clr       lda #0
;          sta crsrfl
&ret      rts
	.)

&crsron .(			; enable cursor
;          bit crsrfl
;          bmi irq               ; already enabled
;          lda #0                ; inverse cursor next crsrirq
;          sta crsrcnt
;          lda #128              ; enabled, but not invers
;          sta crsrfl
;
&irq      
;	  dec crsrcnt
;          bpl ret               ; not this time
;          lda #10
;          sta crsrcnt
;
;          ldy spalte
;          lda (vzei),y
;          eor #$80
;          sta (vzei),y
;          lda crsrfl
;          eor #$40
;          sta crsrfl
;
          rts
          .)

	.)

/**************************************************************************/

rowl	.byt <0,      <80,  <160,  <240,  <320,  <400,  <480,  <560
 	.byt <640,   <720,  <800,  <880,  <960, <1040, <1120, <1200 
	.byt <1280, <1360, <1440, <1520, <1600, <1680, <1760, <1840
	.byt <1920

rowh	.byt >0,      >80,  >160,  >240,  >320,  >400,  >480,  >560
 	.byt >640,   >720,  >800,  >880,  >960, >1040, >1120, >1200 
	.byt >1280, >1360, >1440, >1520, >1600, >1680, >1760, >1840
	.byt >1920

/**************************************************************************/

#include "devices/kbd_c64.a65"

